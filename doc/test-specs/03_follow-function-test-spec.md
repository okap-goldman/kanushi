# フォロー機能テスト仕様書

## 概要
本ドキュメントは「目醒め人のためのSNS」のフォロー機能に関するテスト仕様書です。
TDD（テスト駆動開発）での実装を前提とし、APIユニットテスト、UIユニットテスト、結合テスト、E2Eテストの4種類のテストケースを定義します。

**更新日**: 2025-05-25
**対象機能**: フォロー機能（ファミリー/ウォッチフォロー、アンフォロー、フォロワー/フォロー中一覧）

## テスト環境

### 使用ライブラリ
- `jest-expo@~53.0.0`
- `@testing-library/react-native@^13`
- `@testing-library/jest-native@^6`
- `react-native-reanimated/mock`

### テスト方針
- モックの使用は最小限に抑制
- 実際のAPIレスポンスに近いデータでテスト
- ユーザーインタラクションを重視したテスト設計

---

# 1. APIユニットテスト

## 1.1 フォロー作成API (POST /follows)

### 1.1.1 ファミリーフォロー正常系

**テストケース**: ファミリーフォロー作成（理由あり）
- **入力**: ユーザーID、フォロータイプ（family）、フォロー理由
- **期待結果**: ステータス201、フォローレコード作成、理由が保存される

**テストケース**: ファミリーフォロー作成（理由なし）
- **入力**: ユーザーID、フォロータイプ（family）、理由なし
- **期待結果**: バリデーションエラー（400）、「ファミリーフォローには理由の入力が必要です」メッセージ

### 1.1.2 ウォッチフォロー正常系

**テストケース**: ウォッチフォロー作成（理由なし）
- **入力**: ユーザーID、フォロータイプ（watch）
- **期待結果**: ステータス201、フォローレコード作成、理由はnull

**テストケース**: ウォッチフォロー作成（理由あり）
- **入力**: ユーザーID、フォロータイプ（watch）、任意のフォロー理由
- **期待結果**: ステータス201、フォローレコード作成、任意の理由が保存される

### 1.1.3 フォロー作成異常系

**テストケース**: 重複フォロー
- **入力**: すでにフォロー済みのユーザーに対する再フォロー
- **期待結果**: ステータス409、「すでにフォローしています」エラー

**テストケース**: 自分自身のフォロー
- **入力**: 自分自身のユーザーIDに対するフォロー
- **期待結果**: ステータス400、「自分自身をフォローすることはできません」エラー

**テストケース**: レート制限
- **入力**: 短時間での多数のフォローリクエスト（20件超）
- **期待結果**: ステータス429、「RATE_LIMIT_EXCEEDED」エラー

## 1.2 アンフォローAPI (DELETE /follows/{followId})

### 1.2.1 アンフォロー正常系

**テストケース**: 理由ありアンフォロー
- **入力**: フォローID、アンフォロー理由
- **期待結果**: ステータス204、フォローレコード削除

**テストケース**: 理由なしアンフォロー
- **入力**: フォローID、理由なし
- **期待結果**: ステータス204、フォローレコード削除

### 1.2.2 アンフォロー異常系

**テストケース**: 存在しないフォローのアンフォロー
- **入力**: 存在しないフォローID
- **期待結果**: ステータス404、「RESOURCE_NOT_FOUND」エラー

**テストケース**: 他ユーザーのフォロー関係のアンフォロー
- **入力**: 自分が作成していないフォローID
- **期待結果**: ステータス403、「他のユーザーのフォロー関係は操作できません」エラー

## 1.3 フォロワー一覧取得API (GET /users/{userId}/followers)

### 1.3.1 フォロワー一覧正常系

**テストケース**: ページネーション付きフォロワー一覧取得
- **入力**: ユーザーID、limit=20
- **期待結果**: ステータス200、フォロワーリスト（ユーザー情報、フォロータイプ、理由、相互フォロー状態を含む）

**テストケース**: フォロワーがいないユーザーの一覧取得
- **入力**: フォロワーがいないユーザーID
- **期待結果**: ステータス200、空の配列、nextCursor=null

**テストケース**: カーソルページネーション
- **入力**: 多数のフォロワーがいるユーザーID、最初のページの結果から取得したカーソル
- **期待結果**: ステータス200、次のページのフォロワーリスト（重複なし）

## 1.4 フォロー中一覧取得API (GET /users/{userId}/following)

### 1.4.1 フォロー中一覧正常系

**テストケース**: 最新投稿付きフォロー中一覧取得
- **入力**: ユーザーID
- **期待結果**: ステータス200、フォロー中ユーザーリスト（ユーザー情報、フォロータイプ、最新投稿情報を含む）

**テストケース**: フォロータイプでのフィルタリング
- **入力**: ユーザーID、type=family または type=watch
- **期待結果**: ステータス200、指定したタイプのフォローのみを含むリスト

**テストケース**: 投稿のないユーザーの処理
- **入力**: 投稿のないユーザーをフォローしているユーザーID
- **期待結果**: ステータス200、latestPost=null のユーザーを含むリスト

---

# 2. UIユニットテスト

## 2.1 フォローボタンコンポーネント

### 2.1.1 フォローボタン表示テスト

**テストケース**: 未フォローユーザーに対するボタン表示
- **入力**: userId, followStatus='not_following'
- **期待結果**: 「フォロー」ボタンが表示される

**テストケース**: フォロー済みユーザーに対するボタン表示
- **入力**: userId, followStatus='following', followType='family'
- **期待結果**: 「フォロー中」ボタンとファミリーバッジが表示される

**テストケース**: フォロー処理中のローディング表示
- **入力**: userId, followStatus='not_following', isLoading=true
- **期待結果**: ローディングスピナーが表示され、ボタンが無効化される

### 2.1.2 フォローボタンインタラクション

**テストケース**: フォローボタンプレス時のモーダル表示
- **入力**: 「フォロー」ボタンをタップ
- **期待結果**: フォロー種類選択モーダル（ファミリー/ウォッチ）が表示される

**テストケース**: フォロー中ボタン長押し時のアンフォロー確認
- **入力**: 「フォロー中」ボタンを長押し
- **期待結果**: アンフォロー確認ダイアログが表示される

## 2.2 フォロー理由入力ダイアログ

### 2.2.1 ファミリーフォロー理由入力

**テストケース**: ファミリーフォロー理由入力ダイアログ表示
- **入力**: visible=true, followType='family'
- **期待結果**: 「ファミリーフォローの理由」タイトル、理由入力フィールド、無効状態の「フォロー」ボタン

**テストケース**: 理由入力時のボタン有効化
- **入力**: 理由を入力
- **期待結果**: 「フォロー」ボタンが有効になる

**テストケース**: 理由入力とフォロー実行
- **入力**: 理由を入力して「フォロー」ボタンをタップ
- **期待結果**: onSubmitコールバックが適切なパラメータで呼び出される

### 2.2.2 ウォッチフォロー即時実行

**テストケース**: ウォッチフォロー処理
- **入力**: visible=true, followType='watch'
- **期待結果**: 「フォロー」ボタンをタップするとすぐにonSubmitコールバックが呼び出される（理由はnull）

## 2.3 フォロワー/フォロー中一覧コンポーネント

### 2.3.1 フォロワー一覧表示

**テストケース**: フォロワー一覧の表示
- **入力**: フォロワーデータの配列
- **期待結果**: 各フォロワーの表示名、プロフィール画像、フォロータイプが表示される

**テストケース**: 相互フォロー表示
- **入力**: isFollowingBack=true/false のフォロワーデータ
- **期待結果**: 相互フォロー中のユーザーには相互フォローアイコンが表示される

**テストケース**: ユーザープレス処理
- **入力**: フォロワーリスト内のユーザーをタップ
- **期待結果**: onUserPressコールバックが対象ユーザーIDで呼び出される

### 2.3.2 フォロー中一覧表示

**テストケース**: 最新投稿付きフォロー中一覧
- **入力**: ユーザーと最新投稿データを含むフォロー中データの配列
- **期待結果**: 各フォロー中ユーザーの表示名、プロフィール画像、最新投稿内容、投稿タイプアイコンが表示される

**テストケース**: フォロータイプでのフィルタリング表示
- **入力**: selectedFilter='family'のフォロー中リスト
- **期待結果**: 「ファミリー」フィルターがアクティブ表示され、family タイプのフォローのみ表示される

---

# 3. 結合テスト

## 3.1 フォロー処理の全体フロー

### 3.1.1 ファミリーフォロー完全フロー

**テストケース**: 通知付きファミリーフォロー完全フロー
- **前提条件**: 通知設定有効のターゲットユーザーとフォローするユーザー
- **手順**:
  1. ユーザープロフィール画面でフォローボタンをタップ
  2. ファミリーフォローを選択
  3. フォロー理由を入力
  4. フォロー確定
- **期待結果**:
  - フォローボタンが「フォロー中」に変わる
  - ターゲットユーザーに通知が送信される

### 3.1.2 アンフォロー完全フロー

**テストケース**: アンフォロー完全フロー
- **前提条件**: 既にフォロー済みのユーザー関係
- **手順**:
  1. フォロー中ボタンを長押し
  2. アンフォローを選択
  3. アンフォロー理由を入力（任意）
  4. 確定ボタンをタップ
- **期待結果**:
  - ボタンが「フォロー」状態に戻る
  - フォローレコードがunfollowed状態で更新される
  - アンフォロー理由が記録される

## 3.2 リアルタイム更新テスト

### 3.2.1 フォロワー数のリアルタイム更新

**テストケース**: フォロワー数のリアルタイム更新
- **前提条件**: 対象ユーザーと複数のフォロワー候補
- **手順**:
  1. 対象ユーザーのプロフィール画面を表示（フォロワー数0）
  2. 別ユーザーから対象ユーザーへのフォロー操作をシミュレート
  3. さらに別のユーザーからのフォローをシミュレート
- **期待結果**:
  - 最初のフォロー後、フォロワー数が1に更新される
  - 2つ目のフォロー後、フォロワー数が2に更新される

## 3.3 データ整合性テスト

### 3.3.1 フォロー状態の一貫性

**テストケース**: 画面間でのフォロー状態一貫性
- **前提条件**: 対象ユーザーと現在のユーザー
- **手順**:
  1. プロフィール画面でユーザーをフォロー
  2. フォロー中一覧画面に移動
  3. タイムライン画面に移動し、フォロー中ユーザーが投稿
- **期待結果**:
  - フォロー中一覧にフォローしたユーザーが表示される
  - ウォッチタイムラインにフォローしたユーザーの投稿が表示される

---

# 4. E2Eテスト

## 4.1 ユーザーストーリーベーステスト

### 4.1.1 新規ユーザーの初回フォロー体験

**テストケース**: 新規ユーザーのフォロー初体験
- **前提条件**: 初回ログインの新規ユーザー、人気投稿のあるおすすめユーザー
- **手順**:
  1. ディスカバー画面でおすすめユーザーを表示
  2. おすすめユーザーをタップ
  3. プロフィールでフォローボタンをタップ
  4. 初回ユーザー向けフォロータイプ説明を表示
  5. ファミリーフォローを選択
  6. 有意義な理由を入力してフォロー
- **期待結果**:
  - フォロー状態になり、ファミリーバッジが表示される
  - ファミリータイムラインに移動すると対象ユーザーの投稿が表示される

### 4.1.2 相互フォロー発見と深い繋がり構築

**テストケース**: 相互フォロー関係構築
- **前提条件**: 2人のユーザー
- **手順**:
  1. ユーザー1がユーザー2をウォッチフォロー
  2. ユーザー2が通知を確認し、ユーザー1がフォローしたことを確認
  3. ユーザー1のプロフィールを確認
  4. ファミリーフォローで返す（理由：「私の投稿にも興味を持ってくれたので、ぜひ交流したいです」）
- **期待結果**:
  - 相互フォロー表示が出る
  - ユーザー1にもフォローバック通知が届く

## 4.2 複数ユーザーシナリオ

### 4.2.1 コミュニティ形成シナリオ

**テストケース**: フォローを通じたコミュニティ形成
- **前提条件**: スピリチュアル先生（認証済み）と3人の生徒
- **手順**:
  1. 先生が価値ある音声コンテンツを投稿
  2. 生徒たちが先生をファミリーフォロー
  3. 生徒1が先生のフォロワーリストから他の生徒を発見
  4. 生徒1が他の生徒をウォッチフォロー
- **期待結果**:
  - 生徒1のタイムラインに先生と他の生徒の投稿が表示される
  - 先生側からはコミュニティが形成されていることが確認できる

### 4.2.2 フォロー関係の自然な発展

**テストケース**: ウォッチからファミリーへの関係発展
- **前提条件**: コンテンツクリエイターとフォロワー
- **手順**:
  1. フォロワーが最初にウォッチフォロー
  2. 一定期間、コンテンツに積極的にエンゲージ（いいね、コメント）
  3. 価値を認識し、ファミリーフォローに変更
- **期待結果**:
  - フォロータイプが更新される
  - クリエイターに通知が届く

## 4.3 エラーシナリオと復旧テスト

### 4.3.1 ネットワーク断続時のフォロー操作

**テストケース**: ネットワーク回復力
- **前提条件**: 2人のユーザー
- **手順**:
  1. ユーザープロフィール画面でフォローボタンをタップ
  2. ファミリーフォローを選択し理由を入力
  3. ネットワーク切断をシミュレート
  4. フォロー確定
- **期待結果**:
  - オフライン状態とキューイングメッセージが表示される
  - ネットワーク復旧後、フォロー操作が完了される

---

# 5. テスト実行計画

## 5.1 CI/CDパイプラインでの実行順序

**テスト実行順序**:
1. APIユニットテスト - サービスロジックの検証
2. UIユニットテスト - コンポーネント単体の検証
3. 結合テスト - 複数コンポーネント/サービスの連携検証
4. E2Eテスト - エンドユーザー体験の検証

**テスト設定**:
- APIテスト: サーバー環境（Node.js）
- UIテスト: DOM環境（jsdom）
- テスト固有のセットアップファイル使用

## 5.2 テストデータ管理

### 5.2.1 テスト用ユーザー作成ヘルパー

**テスト用ヘルパー関数**:
- `createTestUser()` - テスト用ユーザーを作成
- `createFollowRelation()` - テスト用フォロー関係を作成

### 5.2.2 モックサービス設定

**モック対象**:
- 通知サービス - プッシュ通知送信のモック
- リアルタイムサービス - WebSocket通信のモック
- ストレージサービス - 結合テスト以外でのモック

## 5.3 カバレッジ目標

| テストタイプ | 目標カバレッジ | 重要ファイル |
|-------------|---------------|--------------| 
| APIユニット | 95%+ | followApi.ts, followService.ts | 
| UIユニット | 90%+ | FollowButton.tsx, FollowDialog.tsx | 
| 結合テスト | 85%+ | フォロー関連コンポーネント群 | 
| E2Eテスト | 主要ユーザーフロー100% | 全体的なフロー |

---

# 6. テスト実装時の注意事項

## 6.1 非同期処理のテスト

**推奨事項**:
- タイムアウトを適切に設定する（特に外部サービス連携時）
- waitFor を使用して非同期処理の完了を待つ
- 短時間で終了する安定したテストを書く

## 6.2 状態管理のテスト

**推奨事項**:
- コンポーネント間の状態共有を検証
- フォロー状態変更が複数画面に正しく反映されることを確認
- 状態管理ライブラリとの連携を確認

## 6.3 エラーハンドリングのテスト

**推奨事項**:
- すべてのエラーケースを網羅的にテスト
- ネットワークエラー、バリデーションエラー、権限エラーなどを確認
- ユーザーフレンドリーなエラーメッセージが表示されることを確認

このテスト仕様書により、フォロー機能の全ての側面を包括的にテストし、高品質で信頼性の高い実装を保証することができます。